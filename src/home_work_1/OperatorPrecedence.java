package home_work_1;

public class OperatorPrecedence {
    public static void main(String args[]) {
        int i, j;
        /**
         * 2.1 5 + 2 / 8
         * Здесь результат равен 5.
         * На первом шаге выполняется целочисленное деление 2 / 8 = 0 (дробная часть при целочисленном делении
         * теряется), а затем к результату прибавляется 5.
         */
        i = 5 + 2 / 8;
        System.out.println(i);

        /**
         * 2.2 (5 + 2) / 8
         * Результат 0.
         * Вначале 5 + 2 = 7, затем целочисленное деление 7 / 8 = 0.
         */
        i = 7 / 8;
        System.out.println(i);

        /**
         * 2.3 (5 + 2++) / 8
         * Вначале выполняем выражение в скобках. Оператор инкремента имеет более высокий проритет, чем 
         * оператор сложение, поэтому вначале выполняем постинкремент. Операция постинкремента в качестве 
         * результата своего выполения возвращает значение переменной ДО операции инкремента, т. е. в 
         * данном случае вместо i++ подставляется значение 2, хотя значение переменной i уже равно 3.
         * Сумма 5 + 2 = 7 целочисленно делится на 8 и получаем 0.
         */
        i = 2;
        System.out.println((5 + i++) / 8);
        
        /**
         * 2.4 (5 + 2++) / --8
         * На переменную 8 действует два оператора -- деление и предектремент. Поскольку предектремент имеет 
         * более высокий приоритет, чем деление, то он выполняет первым. 
         * Результатом операции предекремента является значение операнда уменьшенное на единицу, в данном 
         * случае это 7.
         * Оператор "скобки" имеет наивысший приоритет, а потому выражение в скобках вычисляется до операции деления.
         * В скобках на переменную 2 действуют два оператора -- постинкремент и сложение. Поскольку постинктемент 
         * выше приоритетом, чем сложение, что вначале выполняется 2++. Операция постинкремент увеличивает значение 
         * на единицу, но возвращает предыдущее значение (значение до инкремента). Поэтому в выражение 
         * (5 + 2++) равно 7, хотя сразу после постинктемента значение переменной 2 в памяти увеличивается на единицу.
         * Итог: 7 / 7 = 1 (целочисленное деление, возвращает целочисленную единицу).
        */
        i = 2;
        j = 8;
        System.out.println((5 + i++) / --j);

        /**
         * 2.5 (5 * 2 >> 2++) / --8
         * Применяем оператор предекремента к 8, она возвращает 7 и одновременно изменяет значение переменной в 
         * памяти на единицу меньшее.
         * В конструкции 5 * 2 >> на двойку действует два оператора, * имеет больший приоритет чем >>.
         * Соответственно, вначале выполяем операцию умножения.
         * В конструкции >> 2++ вначале делаем постинкремент, который возвращает в выражение 2, а саму 2 в памяти 
         * увеличивает на 1.
         * Итого: (5 * 2 >> 2++) превращается в 10 >> 2. Это побитовый сдвиг на 2 позиции вправо с сохранением знака, 
         * то есть в случае применения к отрицательному числу освободившиеся старшие биты заполняются единицами. 
         * В нашем случае сдвигает положительное число, а значит старшие биты будут заполнены нулями:
         * 00001010 >> 2 равно 00000010, что есть 2.
         * Итог: 2 / 7 = 0
         * 
         */
        i = 2;
        j = 8;
        System.out.println((5 * 2 >> i++));

        /**
         * 2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8
         * Постинкремент 2++ возвращает 2.
         * Оператор сдвига имеем приоритет меньше, чем арифметические операторы, поэтому 2 вначале участвует 
         * в операции умножения, а затем в сдвиге.
         * Оператор умножения имеет более высокий приоритет, чем третичный оператор. Поэтому выражение 
         * (5 + 7 > 20 ? 68 : 22 * 2 дожно читаться так: (5 + 7 > 20 ? 68 : (22 * 2)
         * Тогда имеет (false ? 68 : 44), что равно 44.
         * 44 >> 2 это 0b0010_1100 >> 2 = 0b0000_1011 = 11
         * Итого: 11 / 7 = 1
         */
        i = 2;
        j = 8;
        System.out.println((5 + 7 > 20 ? 68 : 22 * 2 >> i++) / --j);

        /**
         * (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
         * Ошибка компиляции поскольку в третичном операторе expression1 ? expression2 : expression3 выражения 
         * expression2 и expression3 должны иметь одинаковый тип.
         */
        
        /**
         * 2.8 6 - 2 > 3 && 12 * 12 <= 119
         * Идем слева направо. Операция минус имеет больший приоритет, чем >. Тогда:
         * (6 - 2) > 3 && 12 * 12 <= 119
         * 4 > 3 && 12 * 12 <= 119
         * Оператор > выше &&:
         * (4 > 3) && 12 * 12 <= 119
         * true && 12 * 12 <= 119
         * Умножение старше логического И и операции <= :
         * true && (12 * 12) <= 119
         * true && 144 <= 119
         * Операция <= старше && :
         * true && (144 <= 119)
         * true && false
         * Итого: true && false это false
         */
        System.out.println(6 - 2 > 3 && 12 * 12 <= 119);

        /**
         * В соответствие с таблицей истинности операции логического И true && false это false.
         */
        System.out.println(true && false);
    }
}
